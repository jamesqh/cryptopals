from os import urandom

import pure_python_gcm.aes_gcm_128 as gcm_hazmat
import pure_python_gcm.constants as const


def encrypt(key, plaintext, assoc_data, encoding='utf-8'):
    """User-facing AES-GCM-128 authenticated encryption function.

    Can take strings, which will be decoded to bytes using the supplied
    "encoding" argument - default utf-8. Bytes preferred, though.
    Uses a random IV from os.urandom, which should be suitable for crypto.
    If you want to use a chosen IV (this is a really bad idea),
    use the hazmat functions yourself.

    Args:
        key (bytes or string): 16 byte encryption key value.
        plaintext (bytes or string): plaintext to be encrypted.
        assoc_data (bytes or string): additional data to be authenticated but not encrypted.
        encoding (string): scheme to encode strings as bytes if necessary.

    Returns:
        (cipher, tag, iv) (tuple of bytes objects)
    """
    if not isinstance(key, bytes):
        try:
            key = key.encode(encoding)
        except Exception as e:
            raise TypeError("Key value must be bytes object or string.") from e
    if len(key) != 16:
        raise ValueError("Key must be 16 bytes"
                         "or a string that decodes to 16 bytes.")
    if not isinstance(plaintext, bytes):
        try:
            plaintext = plaintext.encode(encoding)
        except Exception as e:
            raise TypeError("Plaintext must be bytes object or string.") from e
    if len(plaintext) > const.PLAINTEXT_MAX_LENGTH:
        raise ValueError("Plaintext exceeds max length {0} bytes"
                         .format(const.PLAINTEXT_MAX_LENGTH))
    if not isinstance(assoc_data, bytes):
        try:
            assoc_data = assoc_data.encode(encoding)
        except Exception as e:
            raise TypeError("Associated data must be bytes object or string.")\
                from e
    if len(assoc_data) > const.ASSOC_DATA_MAX_LENGTH:
        raise ValueError("Associated data exceeds max length {0} bytes."
                         .format(const.ASSOC_DATA_MAX_LENGTH))
    iv = urandom(12)
    cipher, tag = gcm_hazmat.GCM_AE(key, iv, plaintext, assoc_data, 16)
    return cipher, tag, iv


def decrypt(key, cipher, assoc_data, iv, tag):
    """User-facing AES-GCM-128 authenticated decryption function.

    For cryptographic reasons, this function will only either:
        return an authenticated plaintext or
        raise a generic FAILURE exception.
    Reasons for failure include but are not limited to:
        incorrect types for arguments
        arguments too long or short (see constants.py)
        tag does not match cipher or associated data
    Hence failure indicates only that the ciphertext or assoc_data
    could not be decrypted and validated, not necessarily that it is invalid.

    Args:
        key (bytes): 16 byte encryption key value.
        cipher (bytes): ciphertext encrypted by AES-GCM-128.
        assoc_data (bytes): additional data to authenticate but not decrypt.
        iv (bytes): initialising value used for encryption.
        tag: authenticated tag generated by AES-GCM-128.

    Returns:
        (plaintext, assoc_data) (tuple):
            plaintext (bytes): decrypted ciphertext, authenticated and determined to be valid.
            assoc_data (bytes): authenticated associated data, returned unchanged but determined to be valid.
    """
    try:
        return gcm_hazmat.GCM_AD(key, iv, cipher, assoc_data, tag, 16)
    except Exception as e:
        raise ValueError("Could not validate message with supplied tag.")